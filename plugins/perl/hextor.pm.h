"BEGIN {\n"
"$INC{'HexChat.pm'} = 'Compiled into the plugin.';\n"
"$INC{'Xchat.pm'} = 'Compiled into the plugin.';\n"
"$INC{'HexChat/Embed.pm'} = 'Compiled into the plugin.';\n"
"$INC{'HexChat/List/Network.pm'} = 'Compiled into the plugin.';\n"
"$INC{'HexChat/List/Network/Entry.pm'} = 'Compiled into the plugin.';\n"
"$INC{'HexChat/List/Network/AutoJoin.pm'} = 'Compiled into the plugin.';\n"
"}\n"
"{\n"
"#line 1 \"lib/HexChat.pm\"\n"
"$SIG{__WARN__} = sub {\n"
"my $message = shift @_;\n"
"my ($package) = caller;\n"
"\n"
"\n"
"my $message_levels =	qr/ERROR|CRITICAL|WARNING|MESSAGE|INFO|DEBUG/i;\n"
"if( $message =~ /^(?:Gtk|GLib|Gdk)(?:-\\w+)?-$message_levels/i ) {\n"
"print STDERR $message;\n"
"} else {\n"
"\n"
"if( defined &HexChat::Internal::print ) {\n"
"HexChat::print( $message );\n"
"} else {\n"
"warn $message;\n"
"}\n"
"}\n"
"};\n"
"\n"
"use File::Spec ();\n"
"use File::Basename ();\n"
"use File::Glob ();\n"
"use List::Util ();\n"
"use Symbol();\n"
"use Time::HiRes ();\n"
"use Carp ();\n"
"\n"
"package HexChat;\n"
"use base qw(Exporter);\n"
"use strict;\n"
"use warnings;\n"
"\n"
"sub PRI_HIGHEST ();\n"
"sub PRI_HIGH ();\n"
"sub PRI_NORM ();\n"
"sub PRI_LOW ();\n"
"sub PRI_LOWEST ();\n"
"\n"
"sub EAT_NONE ();\n"
"sub EAT_HEXCHAT ();\n"
"sub EAT_PLUGIN ();\n"
"sub EAT_ALL ();\n"
"\n"
"sub KEEP ();\n"
"sub REMOVE ();\n"
"sub FD_READ ();\n"
"sub FD_WRITE ();\n"
"sub FD_EXCEPTION ();\n"
"sub FD_NOTSOCKET ();\n"
"\n"
"sub get_context;\n"
"sub HexChat::Internal::context_info;\n"
"sub HexChat::Internal::print;\n"
"\n"
"\n"
"sub EAT_XCHAT ();\n"
"BEGIN {\n"
"*Xchat:: = *HexChat::;\n"
"}\n"
"\n"
"our %EXPORT_TAGS = (\n"
"constants => [\n"
"qw(PRI_HIGHEST PRI_HIGH PRI_NORM PRI_LOW PRI_LOWEST), # priorities\n"
"qw(EAT_NONE EAT_HEXCHAT EAT_XCHAT EAT_PLUGIN EAT_ALL), # callback return values\n"
"qw(FD_READ FD_WRITE FD_EXCEPTION FD_NOTSOCKET), # fd flags\n"
"qw(KEEP REMOVE), # timers\n"
"],\n"
"hooks => [\n"
"qw(hook_server hook_command hook_print hook_timer hook_fd unhook),\n"
"],\n"
"util => [\n"
"qw(register nickcmp strip_code send_modes), # misc\n"
"qw(print prnt printf prntf command commandf emit_print), # output\n"
"qw(find_context get_context set_context), # context\n"
"qw(get_info get_prefs get_list context_info user_info), # input\n"
"qw(plugin_pref_set plugin_pref_get plugin_pref_delete plugin_pref_list), #settings\n"
"],\n"
");\n"
"\n"
"$EXPORT_TAGS{all} = [ map { @{$_} } @EXPORT_TAGS{qw(constants hooks util)}];\n"
"our @EXPORT = @{$EXPORT_TAGS{constants}};\n"
"our @EXPORT_OK = @{$EXPORT_TAGS{all}};\n"
"\n"
"sub register {\n"
"my ($package, $calling_package) = HexChat::Embed::find_pkg();\n"
"my $pkg_info = HexChat::Embed::pkg_info( $package );\n"
"my $filename = $pkg_info->{filename};\n"
"my ($name, $version, $description, $callback) = @_;\n"
"\n"
"if( defined $pkg_info->{gui_entry} ) {\n"
"HexChat::print( \"HexChat::register called more than once in \"\n"
". $pkg_info->{filename} );\n"
"return ();\n"
"}\n"
"\n"
"$description = \"\" unless defined $description;\n"
"if( $callback ) {\n"
"$callback = HexChat::Embed::fix_callback(\n"
"$package, $calling_package, $callback\n"
");\n"
"}\n"
"$pkg_info->{shutdown} = $callback;\n"
"unless( $name && $name =~ /[[:print:]\\w]/ ) {\n"
"$name = \"Not supplied\";\n"
"}\n"
"unless( $version && $version =~ /\\d+(?:\\.\\d+)?/ ) {\n"
"$version = \"NaN\";\n"
"}\n"
"$pkg_info->{gui_entry} =\n"
"HexChat::Internal::register( $name, $version, $description, $filename );\n"
"\n"
"return ();\n"
"}\n"
"\n"
"sub _process_hook_options {\n"
"my ($options, $keys, $store) = @_;\n"
"\n"
"unless( @$keys == @$store ) {\n"
"die 'Number of keys must match the size of the store';\n"
"}\n"
"\n"
"my @results;\n"
"\n"
"if( ref( $options ) eq 'HASH' ) {\n"
"for my $index ( 0 .. @$keys - 1 ) {\n"
"my $key = $keys->[$index];\n"
"if( exists( $options->{ $key } ) && defined( $options->{ $key } ) ) {\n"
"${$store->[$index]} = $options->{ $key };\n"
"}\n"
"}\n"
"}\n"
"\n"
"}\n"
"\n"
"sub hook_server {\n"
"return undef unless @_ >= 2;\n"
"my $message = shift;\n"
"my $callback = shift;\n"
"my $options = shift;\n"
"my ($package, $calling_package) = HexChat::Embed::find_pkg();\n"
"\n"
"$callback = HexChat::Embed::fix_callback(\n"
"$package, $calling_package, $callback\n"
");\n"
"\n"
"my ($priority, $data) = ( HexChat::PRI_NORM, undef );\n"
"_process_hook_options(\n"
"$options,\n"
"[qw(priority data)],\n"
"[\\($priority, $data)],\n"
");\n"
"\n"
"my $pkg_info = HexChat::Embed::pkg_info( $package );\n"
"my $hook = HexChat::Internal::hook_server(\n"
"$message, $priority, $callback, $data, $package\n"
");\n"
"push @{$pkg_info->{hooks}}, $hook if defined $hook;\n"
"return $hook;\n"
"}\n"
"\n"
"sub hook_command {\n"
"return undef unless @_ >= 2;\n"
"my $command = shift;\n"
"my $callback = shift;\n"
"my $options = shift;\n"
"my ($package, $calling_package) = HexChat::Embed::find_pkg();\n"
"\n"
"$callback = HexChat::Embed::fix_callback(\n"
"$package, $calling_package, $callback\n"
");\n"
"\n"
"my ($priority, $help_text, $data) = ( HexChat::PRI_NORM, undef, undef );\n"
"_process_hook_options(\n"
"$options,\n"
"[qw(priority help_text data)],\n"
"[\\($priority, $help_text, $data)],\n"
");\n"
"\n"
"my $pkg_info = HexChat::Embed::pkg_info( $package );\n"
"my $hook = HexChat::Internal::hook_command(\n"
"$command, $priority, $callback, $help_text, $data, $package\n"
");\n"
"push @{$pkg_info->{hooks}}, $hook if defined $hook;\n"
"return $hook;\n"
"}\n"
"\n"
"sub hook_print {\n"
"return undef unless @_ >= 2;\n"
"my $event = shift;\n"
"my $callback = shift;\n"
"my $options = shift;\n"
"my ($package, $calling_package) = HexChat::Embed::find_pkg();\n"
"\n"
"$callback = HexChat::Embed::fix_callback(\n"
"$package, $calling_package, $callback\n"
");\n"
"\n"
"my ($priority, $run_after, $filter, $data) = ( HexChat::PRI_NORM, 0, 0, undef );\n"
"_process_hook_options(\n"
"$options,\n"
"[qw(priority run_after_event filter data)],\n"
"[\\($priority, $run_after, $filter, $data)],\n"
");\n"
"\n"
"if( $run_after and $filter ) {\n"
"Carp::carp( \"HexChat::hook_print's run_after_event and filter options are mutually exclusive, you can only use of them at a time per hook\" );\n"
"return;\n"
"}\n"
"\n"
"if( $run_after ) {\n"
"my $cb = $callback;\n"
"$callback = sub {\n"
"my @args = @_;\n"
"hook_timer( 0, sub {\n"
"$cb->( @args );\n"
"\n"
"if( ref $run_after eq 'CODE' ) {\n"
"$run_after->( @args );\n"
"}\n"
"return REMOVE;\n"
"});\n"
"return EAT_NONE;\n"
"};\n"
"}\n"
"\n"
"if( $filter ) {\n"
"my $cb = $callback;\n"
"$callback = sub {\n"
"my @args = @{$_[0]};\n"
"my $event_data = $_[1];\n"
"my $event_name = $event;\n"
"my $last_arg = @args - 1;\n"
"\n"
"my @new = $cb->( \\@args, $event_data, $event_name );\n"
"\n"
"\n"
"if( @new > @args ) {\n"
"$event_name = pop @new;\n"
"}\n"
"\n"
"\n"
"\n"
"if( @new == @args ) {\n"
"emit_print( $event_name, @new[ 0 .. $last_arg ] );\n"
"return EAT_ALL;\n"
"} elsif(\n"
"join( \"\\0\", @{$_[0]} ) ne join( \"\\0\", @args[ 0 .. $last_arg ] )\n"
") {\n"
"emit_print( $event_name, @args[ 0 .. $last_arg ] );\n"
"return EAT_ALL;\n"
"}\n"
"\n"
"return EAT_NONE;\n"
"};\n"
"\n"
"}\n"
"\n"
"my $pkg_info = HexChat::Embed::pkg_info( $package );\n"
"my $hook = HexChat::Internal::hook_print(\n"
"$event, $priority, $callback, $data, $package\n"
");\n"
"push @{$pkg_info->{hooks}}, $hook if defined $hook;\n"
"return $hook;\n"
"}\n"
"\n"
"sub hook_timer {\n"
"return undef unless @_ >= 2;\n"
"my ($timeout, $callback, $data) = @_;\n"
"my ($package, $calling_package) = HexChat::Embed::find_pkg();\n"
"\n"
"$callback = HexChat::Embed::fix_callback(\n"
"$package, $calling_package, $callback\n"
");\n"
"\n"
"if(\n"
"ref( $data ) eq 'HASH' && exists( $data->{data} )\n"
"&& defined( $data->{data} )\n"
") {\n"
"$data = $data->{data};\n"
"}\n"
"\n"
"my $pkg_info = HexChat::Embed::pkg_info( $package );\n"
"my $hook = HexChat::Internal::hook_timer( $timeout, $callback, $data, $package );\n"
"push @{$pkg_info->{hooks}}, $hook if defined $hook;\n"
"return $hook;\n"
"}\n"
"\n"
"sub hook_fd {\n"
"return undef unless @_ >= 2;\n"
"my ($fd, $callback, $options) = @_;\n"
"return undef unless defined $fd && defined $callback;\n"
"\n"
"my $fileno = fileno $fd;\n"
"return undef unless defined $fileno; # no underlying fd for this handle\n"
"\n"
"my ($package, $calling_package) = HexChat::Embed::find_pkg();\n"
"$callback = HexChat::Embed::fix_callback(\n"
"$package, $calling_package, $callback\n"
");\n"
"\n"
"my ($flags, $data) = (HexChat::FD_READ, undef);\n"
"_process_hook_options(\n"
"$options,\n"
"[qw(flags data)],\n"
"[\\($flags, $data)],\n"
");\n"
"\n"
"my $cb = sub {\n"
"my $userdata = shift;\n"
"return $userdata->{CB}->(\n"
"$userdata->{FD}, $userdata->{FLAGS}, $userdata->{DATA},\n"
");\n"
"};\n"
"\n"
"my $pkg_info = HexChat::Embed::pkg_info( $package );\n"
"my $hook = HexChat::Internal::hook_fd(\n"
"$fileno, $cb, $flags, {\n"
"DATA => $data, FD => $fd, CB => $callback, FLAGS => $flags,\n"
"},\n"
"$package\n"
");\n"
"push @{$pkg_info->{hooks}}, $hook if defined $hook;\n"
"return $hook;\n"
"}\n"
"\n"
"sub unhook {\n"
"my $hook = shift @_;\n"
"my $package = shift @_;\n"
"($package) = caller unless $package;\n"
"my $pkg_info = HexChat::Embed::pkg_info( $package );\n"
"\n"
"if( defined( $hook )\n"
"&& $hook =~ /^\\d+$/\n"
"&& grep { $_ == $hook } @{$pkg_info->{hooks}} ) {\n"
"$pkg_info->{hooks} = [grep { $_ != $hook } @{$pkg_info->{hooks}}];\n"
"return HexChat::Internal::unhook( $hook );\n"
"}\n"
"return ();\n"
"}\n"
"\n"
"sub _do_for_each {\n"
"my ($cb, $channels, $servers) = @_;\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"if( @_ == 3 && !($channels || $servers) ) { \n"
"$channels = [ undef ];\n"
"$servers = [ undef ];\n"
"} elsif( !($channels || $servers) ) {\n"
"$cb->();\n"
"return 1;\n"
"}\n"
"\n"
"$channels = [ $channels ] unless ref( $channels ) eq 'ARRAY';\n"
"\n"
"if( $servers ) {\n"
"$servers = [ $servers ] unless ref( $servers ) eq 'ARRAY';\n"
"} else {\n"
"$servers = [ undef ];\n"
"}\n"
"\n"
"my $num_done = 0;\n"
"my $old_ctx = HexChat::get_context();\n"
"for my $server ( @$servers ) {\n"
"for my $channel ( @$channels ) {\n"
"if( HexChat::set_context( $channel, $server ) ) {\n"
"$cb->();\n"
"$num_done++\n"
"}\n"
"}\n"
"}\n"
"HexChat::set_context( $old_ctx );\n"
"return $num_done;\n"
"}\n"
"\n"
"sub print {\n"
"my $text = shift @_;\n"
"return \"\" unless defined $text;\n"
"if( ref( $text ) eq 'ARRAY' ) {\n"
"if( $, ) {\n"
"$text = join $, , @$text;\n"
"} else {\n"
"$text = join \"\", @$text;\n"
"}\n"
"}\n"
"\n"
"return _do_for_each(\n"
"sub { HexChat::Internal::print( $text ); },\n"
"@_\n"
");\n"
"}\n"
"\n"
"sub printf {\n"
"my $format = shift;\n"
"HexChat::print( sprintf( $format, @_ ) );\n"
"}\n"
"\n"
"\n"
"\n"
"sub prnt {\n"
"goto &HexChat::print;\n"
"}\n"
"\n"
"sub prntf {\n"
"goto &HexChat::printf;\n"
"}\n"
"\n"
"sub command {\n"
"my $command = shift;\n"
"return \"\" unless defined $command;\n"
"my @commands;\n"
"\n"
"if( ref( $command ) eq 'ARRAY' ) {\n"
"@commands = @$command;\n"
"} else {\n"
"@commands = ($command);\n"
"}\n"
"\n"
"return _do_for_each(\n"
"sub { HexChat::Internal::command( $_ ) foreach @commands },\n"
"@_\n"
");\n"
"}\n"
"\n"
"sub commandf {\n"
"my $format = shift;\n"
"HexChat::command( sprintf( $format, @_ ) );\n"
"}\n"
"\n"
"sub plugin_pref_set {\n"
"my $setting = shift // return 0;\n"
"my $value   = shift // return 0;\n"
"\n"
"return HexChat::Internal::plugin_pref_set($setting, $value);\n"
"}\n"
"\n"
"sub plugin_pref_get {\n"
"my $setting = shift // return 0;\n"
"\n"
"return HexChat::Internal::plugin_pref_get($setting);\n"
"}\n"
"\n"
"sub plugin_pref_delete {\n"
"my $setting = shift // return 0;\n"
"\n"
"return HexChat::Internal::plugin_pref_delete($setting);\n"
"}\n"
"\n"
"sub plugin_pref_list {\n"
"my %list = HexChat::Internal::plugin_pref_list();\n"
"\n"
"return \\%list;\n"
"}\n"
"\n"
"sub set_context {\n"
"my $context;\n"
"if( @_ == 2 ) {\n"
"my ($channel, $server) = @_;\n"
"$context = HexChat::find_context( $channel, $server );\n"
"} elsif( @_ == 1 ) {\n"
"if( defined $_[0] && $_[0] =~ /^\\d+$/ ) {\n"
"$context = $_[0];\n"
"} else {\n"
"$context = HexChat::find_context( $_[0] );\n"
"}\n"
"} elsif( @_ == 0 ) {\n"
"$context = HexChat::find_context();\n"
"}\n"
"return $context ? HexChat::Internal::set_context( $context ) : 0;\n"
"}\n"
"\n"
"sub get_info {\n"
"my $id = shift;\n"
"my $info;\n"
"\n"
"if( defined( $id ) ) {\n"
"if( grep { $id eq $_ } qw(state_cursor id) ) {\n"
"$info = HexChat::get_prefs( $id );\n"
"} else {\n"
"$info = HexChat::Internal::get_info( $id );\n"
"}\n"
"}\n"
"return $info;\n"
"}\n"
"\n"
"sub user_info {\n"
"my $nick = HexChat::strip_code(shift @_ || HexChat::get_info( \"nick\" ));\n"
"my $user;\n"
"for (HexChat::get_list( \"users\" ) ) {\n"
"if ( HexChat::nickcmp( $_->{nick}, $nick ) == 0 ) {\n"
"$user = $_;\n"
"last;\n"
"}\n"
"}\n"
"return $user;\n"
"}\n"
"\n"
"sub context_info {\n"
"my $ctx = shift @_ || HexChat::get_context;\n"
"my $old_ctx = HexChat::get_context;\n"
"my @fields = (\n"
"qw(away channel charset host id inputbox libdirfs modes network),\n"
"qw(nick nickserv server topic version win_ptr win_status),\n"
"qw(configdir xchatdir xchatdirfs state_cursor),\n"
");\n"
"\n"
"if( HexChat::set_context( $ctx ) ) {\n"
"my %info;\n"
"for my $field ( @fields ) {\n"
"$info{$field} = HexChat::get_info( $field );\n"
"}\n"
"\n"
"my $ctx_info = HexChat::Internal::context_info;\n"
"@info{keys %$ctx_info} = values %$ctx_info;\n"
"\n"
"HexChat::set_context( $old_ctx );\n"
"return \\%info;\n"
"} else {\n"
"return undef;\n"
"}\n"
"}\n"
"\n"
"sub get_list {\n"
"unless( grep { $_[0] eq $_ } qw(channels dcc ignore notify users networks) ) {\n"
"Carp::carp( \"'$_[0]' does not appear to be a valid list name\" );\n"
"}\n"
"if( $_[0] eq 'networks' ) {\n"
"return HexChat::List::Network->get();\n"
"} else {\n"
"return HexChat::Internal::get_list( $_[0] );\n"
"}\n"
"}\n"
"\n"
"sub strip_code {\n"
"my $pattern = qr<\n"
"\\cB| #Bold\n"
"\\cC\\d{0,2}(?:,\\d{1,2})?| #Color\n"
"\\e\\[(?:\\d{1,2}(?:;\\d{1,2})*)?m| # ANSI color code\n"
"\\cG| #Beep\n"
"\\cO| #Reset\n"
"\\cV| #Reverse\n"
"\\c_  #Underline\n"
">x;\n"
"\n"
"if( defined wantarray ) {\n"
"my $msg = shift;\n"
"$msg =~ s/$pattern//g;\n"
"return $msg;\n"
"} else {\n"
"$_[0] =~ s/$pattern//g if defined $_[0];\n"
"}\n"
"}\n"
"\n"
"1\n"
"}\n"
"{\n"
"#line 1 \"lib/Xchat.pm\"\n"
"require HexChat;\n"
"}\n"
"{\n"
"#line 1 \"lib/HexChat/Embed.pm\"\n"
"package HexChat::Embed;\n"
"use strict;\n"
"use warnings;\n"
"use Data::Dumper;\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"our %scripts;\n"
"\n"
"\n"
"our %owner_package;\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"our $current_package;\n"
"\n"
"sub load {\n"
"my $file = expand_homedir( shift @_ );\n"
"my $package = file2pkg( $file );\n"
"\n"
"if( exists $scripts{$package} ) {\n"
"my $pkg_info = pkg_info( $package );\n"
"my $filename = File::Basename::basename( $pkg_info->{filename} );\n"
"HexChat::printf(\n"
"qq{'%s' already loaded from '%s'.\\n},\n"
"$filename, $pkg_info->{filename}\n"
");\n"
"HexChat::print(\n"
"'If this is a different script then it rename and try '.\n"
"'loading it again.'\n"
");\n"
"return 2;\n"
"}\n"
"\n"
"if( open my $source_handle, $file ) {\n"
"my $source = do {local $/; <$source_handle>};\n"
"close $source_handle;\n"
"\n"
"$source =~ s/^__END__.*//ms;\n"
"\n"
"\n"
"\n"
"$scripts{$package}{filename} = $file;\n"
"$scripts{$package}{loaded_at} = Time::HiRes::time();\n"
"\n"
"\n"
"\n"
"\n"
"my @inner_packages = $source =~\n"
"m/^\\s*package \\s+\n"
"((?:[^\\W:]+(?:::)?)+)\\s*? # package name\n"
"\n"
"(?:\\d+(?:[.]\\d+) # positive integer or decimal-fraction\n"
"|v\\d+(?:[.]\\d+){2,})? # dotted-decimal v-string\n"
"[{;]\n"
"/mgx;\n"
"\n"
"\n"
"\n"
"my @conflicts;\n"
"for my $inner ( @inner_packages ) {\n"
"if( exists $owner_package{ $inner } ) {\n"
"push @conflicts, $inner;\n"
"}\n"
"}\n"
"\n"
"\n"
"if( @conflicts ) {\n"
"my $error_message =\n"
"\"'$file' won't be loaded due to conflicting inner packages:\\n\";\n"
"for my $conflict_package ( @conflicts ) {\n"
"$error_message .= \"   $conflict_package already defined in \" .\n"
"pkg_info($owner_package{ $conflict_package })->{filename}.\"\\n\";\n"
"}\n"
"HexChat::print( $error_message );\n"
"\n"
"return 2;\n"
"}\n"
"\n"
"my $full_path = File::Spec->rel2abs( $file );\n"
"$source =~ s/^/#line 1 \"$full_path\"\\n\\x7Bpackage $package;/;\n"
"\n"
"\n"
"if( $source =~ /^#.*\\Z/m ) {\n"
"$source =~ s/^(?=#.*\\Z)/\\x7D/m;\n"
"} else {\n"
"$source =~ s/\\Z/\\x7D/;\n"
"}\n"
"\n"
"$scripts{$package}{inner_packages} = [ @inner_packages ];\n"
"@owner_package{ @inner_packages } = ($package) x @inner_packages;\n"
"_do_eval( $source );\n"
"\n"
"unless( exists $scripts{$package}{gui_entry} ) {\n"
"$scripts{$package}{gui_entry} =\n"
"HexChat::Internal::register(\n"
"\"\", \"unknown\", \"\", $file\n"
");\n"
"}\n"
"\n"
"if( $@ ) {\n"
"\n"
"$@ =~ s/\\(eval \\d+\\)/$file/g;\n"
"HexChat::print( \"Error loading '$file':\\n$@\\n\" );\n"
"\n"
"unload( $scripts{$package}{filename} );\n"
"return 1;\n"
"}\n"
"} else {\n"
"HexChat::print( \"Error opening '$file': $!\\n\" );\n"
"return 2;\n"
"}\n"
"\n"
"return 0;\n"
"}\n"
"\n"
"sub _do_eval {\n"
"no strict;\n"
"no warnings;\n"
"eval $_[0];\n"
"}\n"
"\n"
"sub unload {\n"
"my $file = shift @_;\n"
"my $package = file2pkg( $file );\n"
"my $pkg_info = pkg_info( $package );\n"
"\n"
"if( $pkg_info ) {	\n"
"\n"
"if( exists $pkg_info->{shutdown} ) {\n"
"\n"
"eval {\n"
"if( ref $pkg_info->{shutdown} eq 'CODE' ) {\n"
"$pkg_info->{shutdown}->();\n"
"} elsif ( $pkg_info->{shutdown} ) {\n"
"no strict 'refs';\n"
"&{$pkg_info->{shutdown}};\n"
"}\n"
"};\n"
"}\n"
"\n"
"if( exists $pkg_info->{hooks} ) {\n"
"for my $hook ( @{$pkg_info->{hooks}} ) {\n"
"HexChat::unhook( $hook, $package );\n"
"}\n"
"}\n"
"\n"
"if( exists $pkg_info->{gui_entry} ) {\n"
"plugingui_remove( $pkg_info->{gui_entry} );\n"
"}\n"
"\n"
"delete @owner_package{ @{$pkg_info->{inner_packages}} };\n"
"for my $inner_package ( @{$pkg_info->{inner_packages}} ) {\n"
"Symbol::delete_package( $inner_package );\n"
"}\n"
"Symbol::delete_package( $package );\n"
"delete $scripts{$package};\n"
"return HexChat::EAT_ALL;\n"
"} else {\n"
"HexChat::print( qq{\"$file\" is not loaded.\\n} );\n"
"return HexChat::EAT_NONE;\n"
"}\n"
"}\n"
"\n"
"sub unload_all {\n"
"for my $package ( keys %scripts ) {\n"
"unload( $scripts{$package}->{filename} );\n"
"}\n"
"\n"
"return HexChat::EAT_ALL;\n"
"}\n"
"\n"
"sub reload {\n"
"my $file = shift @_;\n"
"my $package = file2pkg( $file );\n"
"my $pkg_info = pkg_info( $package );\n"
"my $fullpath = $file;\n"
"\n"
"if( $pkg_info ) {\n"
"$fullpath = $pkg_info->{filename};\n"
"unload( $file );\n"
"}\n"
"\n"
"load( $fullpath );\n"
"return HexChat::EAT_ALL;\n"
"}\n"
"\n"
"sub reload_all {\n"
"my @dirs = HexChat::get_info( \"configdir\" );\n"
"push @dirs, File::Spec->catdir( $dirs[0], \"plugins\" );\n"
"for my $dir ( @dirs ) {\n"
"my $auto_load_glob = File::Spec->catfile( $dir, \"*.pl\" );\n"
"my @scripts = map { $_->{filename} }\n"
"sort { $a->{loaded_at} <=> $b->{loaded_at} } values %scripts;\n"
"push @scripts, File::Glob::bsd_glob( $auto_load_glob );\n"
"\n"
"my %seen;\n"
"@scripts = grep { !$seen{ $_ }++ } @scripts;\n"
"\n"
"unload_all();\n"
"for my $script ( @scripts ) {\n"
"if( !pkg_info( file2pkg( $script ) ) ) {\n"
"load( $script );\n"
"}\n"
"}\n"
"}\n"
"}\n"
"\n"
"sub evaluate {\n"
"my ($code) = @_;\n"
"\n"
"my @results = eval $code;\n"
"HexChat::print $@ if $@; #print warnings\n"
"\n"
"local $Data::Dumper::Sortkeys = 1;\n"
"local $Data::Dumper::Terse    = 1;\n"
"\n"
"if (@results > 1) {\n"
"HexChat::print Dumper \\@results;\n"
"}\n"
"elsif (ref $results[0] || !$results[0]) {\n"
"HexChat::print Dumper $results[0];\n"
"}\n"
"else {\n"
"HexChat::print $results[0];\n"
"}\n"
"\n"
"return HexChat::EAT_HEXCHAT;\n"
"};\n"
"\n"
"sub expand_homedir {\n"
"my $file = shift @_;\n"
"\n"
"if ( $^O eq \"MSWin32\" ) {\n"
"$file =~ s/^~/$ENV{USERPROFILE}/;\n"
"} else {\n"
"$file =~ s{^~}{\n"
"(getpwuid($>))[7] ||  $ENV{HOME} || $ENV{LOGDIR}\n"
"}ex;\n"
"}\n"
"return $file;\n"
"}\n"
"\n"
"sub file2pkg {\n"
"my $string = File::Basename::basename( shift @_ );\n"
"$string =~ s/\\.pl$//i;\n"
"$string =~ s|([^A-Za-z0-9/])|'_'.unpack(\"H*\",$1)|eg;\n"
"return \"HexChat::Script::\" . $string;\n"
"}\n"
"\n"
"sub pkg_info {\n"
"my $package = shift @_;\n"
"return $scripts{$package};\n"
"}\n"
"\n"
"sub find_external_pkg {\n"
"my $level = 1;\n"
"\n"
"while( my @frame = caller( $level ) ) {\n"
"return @frame if $frame[0] !~ /(?:^IRC$|^HexChat)/;\n"
"$level++;\n"
"}\n"
"return;\n"
"}\n"
"\n"
"sub find_pkg {\n"
"my $level = 1;\n"
"\n"
"while( my ($package, $file, $line) = caller( $level ) ) {\n"
"return $package if $package =~ /^HexChat::Script::/;\n"
"$level++;\n"
"}\n"
"\n"
"my $current_package = get_current_package();\n"
"if( defined $current_package ) {\n"
"return $current_package;\n"
"}\n"
"\n"
"my @frame = find_external_pkg();\n"
"my $location;\n"
"\n"
"if( $frame[0] or $frame[1] ) {\n"
"my $calling_package = $frame[0];\n"
"if( defined( my $owner = $owner_package{ $calling_package } ) ) {\n"
"return ($owner, $calling_package);\n"
"}\n"
"\n"
"$location = $frame[1] ? $frame[1] : \"package $frame[0]\";\n"
"$location .= \" line $frame[2]\";\n"
"} else {\n"
"$location = \"unknown location\";\n"
"}\n"
"\n"
"die \"Unable to determine which script this hook belongs to. at $location\\n\";\n"
"\n"
"}\n"
"\n"
"\n"
"sub fix_callback {\n"
"my ($package, $calling_package, $callback) = @_;\n"
"\n"
"unless( ref $callback ) {\n"
"unless( $callback =~ /::/ ) {\n"
"my $prefix = defined $calling_package ? $calling_package : $package;\n"
"$callback =~ s/^/${prefix}::/;\n"
"}\n"
"\n"
"no strict 'subs';\n"
"$callback = \\&{$callback};\n"
"}\n"
"\n"
"return $callback;\n"
"}\n"
"\n"
"sub get_current_package {\n"
"return $current_package;\n"
"}\n"
"\n"
"sub set_current_package {\n"
"my $old_package = $current_package;\n"
"$current_package = shift;\n"
"\n"
"return $old_package;\n"
"}\n"
"\n"
"1\n"
"}\n"
"{\n"
"#line 1 \"lib/HexChat/List/Network.pm\"\n"
"package HexChat::List::Network;\n"
"use strict;\n"
"use warnings;\n"
"use Storable qw(dclone);\n"
"my $last_modified;\n"
"my @servers;\n"
"\n"
"sub get {\n"
"my $server_file = HexChat::get_info( \"configdir\" ) . \"/servlist.conf\";\n"
"\n"
"\n"
"if( -f $server_file && \n"
"(!defined $last_modified || $last_modified != -M $server_file ) ) {\n"
"$last_modified = -M _;\n"
"\n"
"@servers = ();\n"
"if( open my $fh, \"<\", $server_file ) {\n"
"local $/ = \"\\n\\n\";\n"
"while( my $record = <$fh> ) {\n"
"chomp $record;\n"
"next if $record =~ /^v=/; # skip the version line\n"
"push @servers, HexChat::List::Network::Entry::parse( $record );\n"
"}\n"
"} else {\n"
"warn \"Unable to open '$server_file': $!\";\n"
"}\n"
"}\n"
"\n"
"my $clone = dclone( \\@servers );\n"
"return @$clone;\n"
"}\n"
"\n"
"1\n"
"}\n"
"{\n"
"#line 1 \"lib/HexChat/List/Network/Entry.pm\"\n"
"package HexChat::List::Network::Entry;\n"
"use strict;\n"
"use warnings;\n"
"\n"
"my %key_for = (\n"
"I => \"irc_nick1\",\n"
"i => \"irc_nick2\",\n"
"U => \"irc_user_name\",\n"
"R => \"irc_real_name\",\n"
"P => \"server_password\",\n"
"B => \"nickserv_password\",\n"
"N => \"network\",\n"
"D => \"selected\",\n"
"E => \"encoding\",\n"
");\n"
"my $letter_key_re = join \"|\", keys %key_for;\n"
"\n"
"sub parse {\n"
"my $data  = shift;\n"
"my $entry = {\n"
"irc_nick1       => undef,\n"
"irc_nick2       => undef,\n"
"irc_user_name   => undef,\n"
"irc_real_name   => undef,\n"
"server_password => undef,\n"
"\n"
"\n"
"\n"
"autojoins         => HexChat::List::Network::AutoJoin->new( '' ),\n"
"connect_commands   => [],\n"
"flags             => {},\n"
"selected          => undef,\n"
"encoding          => undef,\n"
"servers           => [],\n"
"nickserv_password => undef,\n"
"network           => undef,\n"
"};\n"
"\n"
"my @fields = split /\\n/, $data;\n"
"chomp @fields;\n"
"\n"
"$entry->{ autojoins } = HexChat::List::Network::AutoJoin->new();\n"
"\n"
"for my $field ( @fields ) {\n"
"SWITCH: for ( $field ) {\n"
"/^($letter_key_re)=(.*)/ && do {\n"
"$entry->{ $key_for{ $1 } } = $2;\n"
"last SWITCH;\n"
"};\n"
"\n"
"/^J.(.*)/ && do {\n"
"$entry->{ autojoins }->add( $1 );\n"
"};\n"
"\n"
"/^F.(.*)/ && do {\n"
"$entry->{ flags } = parse_flags( $1 );\n"
"};\n"
"\n"
"/^S.(.+)/ && do {\n"
"push @{$entry->{servers}}, parse_server( $1 );\n"
"};\n"
"\n"
"/^C.(.+)/ && do {\n"
"push @{$entry->{connect_commands}}, $1;\n"
"};\n"
"}\n"
"}\n"
"\n"
"\n"
"return $entry;\n"
"}\n"
"\n"
"sub parse_flags {\n"
"my $value = shift || 0;\n"
"my %flags;\n"
"\n"
"$flags{ \"cycle\" }         = $value & 1  ? 1 : 0;\n"
"$flags{ \"use_global\" }    = $value & 2  ? 1 : 0;\n"
"$flags{ \"use_ssl\" }       = $value & 4  ? 1 : 0;\n"
"$flags{ \"autoconnect\" }   = $value & 8  ? 1 : 0;\n"
"$flags{ \"use_proxy\" }     = $value & 16 ? 1 : 0;\n"
"$flags{ \"allow_invalid\" } = $value & 32 ? 1 : 0;\n"
"\n"
"return \\%flags;\n"
"}\n"
"\n"
"sub parse_server {\n"
"my $data = shift;\n"
"if( $data ) {\n"
"my ($host, $port) = split /\\//, $data;\n"
"unless( $port ) {\n"
"my @parts = split /:/, $host;\n"
"\n"
"\n"
"\n"
"if( @parts == 2 ) {\n"
"$port = $parts[1];\n"
"}\n"
"}\n"
"\n"
"$port ||= 6667;\n"
"return { host => $host, port => $port };\n"
"}\n"
"}\n"
"\n"
"1\n"
"}\n"
"{\n"
"#line 1 \"lib/HexChat/List/Network/AutoJoin.pm\"\n"
"package HexChat::List::Network::AutoJoin;\n"
"use strict;\n"
"use warnings;\n"
"\n"
"use overload\n"
"\n"
"\n"
"'\"\"'   => 'as_string',\n"
"'0+'   => 'as_bool';\n"
"\n"
"sub new {\n"
"my $class = shift;\n"
"\n"
"my @autojoins;\n"
"\n"
"return bless \\@autojoins, $class;\n"
"}\n"
"\n"
"sub add {\n"
"my $self = shift;\n"
"\n"
"my $line = shift;\n"
"\n"
"my ( $channel, $key ) = split /,/, $line, 2;\n"
"$key = $key || '';\n"
"\n"
"push @$self, {\n"
"channel => $channel,\n"
"key     => $key,\n"
"};\n"
"}\n"
"\n"
"sub channels {\n"
"my $self = shift;\n"
"\n"
"if( wantarray ) {\n"
"return map { $_->{channel} } @$self;\n"
"} else {\n"
"return scalar @$self;\n"
"}\n"
"}\n"
"\n"
"sub keys {\n"
"my $self = shift;\n"
"return map { $_->{key} } @$self  ;\n"
"\n"
"}\n"
"\n"
"sub pairs {\n"
"my $self = shift;\n"
"\n"
"my @channels = $self->channels;\n"
"my @keys = $self->keys;\n"
"\n"
"my @pairs = map { $_ => shift @keys } @channels;\n"
"}\n"
"\n"
"sub as_hash {\n"
"my $self = shift;\n"
"return +{ $self->pairs };\n"
"}\n"
"\n"
"sub as_string {\n"
"my $self = shift;\n"
"return join \" \",\n"
"join( \",\", $self->channels ),\n"
"join( \",\", $self->keys );\n"
"}\n"
"\n"
"sub as_array {\n"
"my $self = shift;\n"
"return [ map { \\%$_ } @$self ];\n"
"}\n"
"\n"
"sub as_bool {\n"
"my $self = shift;\n"
"return $self->channels ? 1 : \"\";\n"
"}\n"
"\n"
"1\n"
"}\n"
